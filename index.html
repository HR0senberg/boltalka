<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>P2P Чат</title>
  <style>
    /* Design System Variables */
    :root {
      --color-white: rgba(255, 255, 255, 1);
      --color-black: rgba(0, 0, 0, 1);
      --color-cream-50: rgba(252, 252, 249, 1);
      --color-cream-100: rgba(255, 255, 253, 1);
      --color-gray-200: rgba(245, 245, 245, 1);
      --color-gray-300: rgba(167, 169, 169, 1);
      --color-gray-400: rgba(119, 124, 124, 1);
      --color-slate-500: rgba(98, 108, 113, 1);
      --color-brown-600: rgba(94, 82, 64, 1);
      --color-charcoal-700: rgba(31, 33, 33, 1);
      --color-charcoal-800: rgba(38, 40, 40, 1);
      --color-slate-900: rgba(19, 52, 59, 1);
      --color-teal-300: rgba(50, 184, 198, 1);
      --color-teal-400: rgba(45, 166, 178, 1);
      --color-teal-500: rgba(33, 128, 141, 1);
      --color-teal-600: rgba(29, 116, 128, 1);
      --color-teal-700: rgba(26, 104, 115, 1);
      --color-red-400: rgba(255, 84, 89, 1);
      --color-red-500: rgba(192, 21, 47, 1);
      --color-orange-400: rgba(230, 129, 97, 1);
      --color-orange-500: rgba(168, 75, 47, 1);
      --color-brown-600-rgb: 94, 82, 64;
      --color-teal-500-rgb: 33, 128, 141;
      --color-slate-900-rgb: 19, 52, 59;
      --color-background: var(--color-cream-50);
      --color-surface: var(--color-cream-100);
      --color-text: var(--color-slate-900);
      --color-text-secondary: var(--color-slate-500);
      --color-primary: var(--color-teal-500);
      --color-primary-hover: var(--color-teal-600);
      --color-primary-active: var(--color-teal-700);
      --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
      --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
      --color-border: rgba(var(--color-brown-600-rgb), 0.2);
      --color-btn-primary-text: var(--color-cream-50);
      --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
      --color-error: var(--color-red-500);
      --color-success: var(--color-teal-500);
      --color-warning: var(--color-orange-500);
      --font-family-base: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      --font-size-sm: 12px;
      --font-size-base: 14px;
      --font-size-lg: 16px;
      --font-size-xl: 18px;
      --font-size-2xl: 20px;
      --font-size-3xl: 24px;
      --space-4: 4px;
      --space-8: 8px;
      --space-12: 12px;
      --space-16: 16px;
      --space-20: 20px;
      --space-24: 24px;
      --space-32: 32px;
      --radius-base: 8px;
      --radius-md: 10px;
      --radius-lg: 12px;
      --radius-full: 9999px;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.04), 0 2px 4px -1px rgba(0, 0, 0, 0.02);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --color-gray-400-rgb: 119, 124, 124;
        --color-teal-300-rgb: 50, 184, 198;
        --color-gray-300-rgb: 167, 169, 169;
        --color-gray-200-rgb: 245, 245, 245;
        --color-background: var(--color-charcoal-700);
        --color-surface: var(--color-charcoal-800);
        --color-text: var(--color-gray-200);
        --color-text-secondary: rgba(var(--color-gray-300-rgb), 0.7);
        --color-primary: var(--color-teal-300);
        --color-primary-hover: var(--color-teal-400);
        --color-secondary: rgba(var(--color-gray-400-rgb), 0.15);
        --color-secondary-hover: rgba(var(--color-gray-400-rgb), 0.25);
        --color-border: rgba(var(--color-gray-400-rgb), 0.3);
        --color-btn-primary-text: var(--color-slate-900);
        --color-card-border: rgba(var(--color-gray-400-rgb), 0.2);
        --color-error: var(--color-red-400);
        --color-success: var(--color-teal-300);
        --color-warning: var(--color-orange-400);
      }
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-family-base);
      background-color: var(--color-background);
      color: var(--color-text);
      -webkit-font-smoothing: antialiased;
      overflow-x: hidden;
      width: 100%;
      max-width: 100vw;
    }

    #app {
      width: 100%;
      max-width: 100vw;
      overflow-x: hidden;
    }

    .screen {
      display: none;
      padding: var(--space-20);
      min-height: 100vh;
    }

    .screen.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .container {
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
    }

    h1 {
      font-size: var(--font-size-3xl);
      font-weight: 600;
      margin-bottom: var(--space-32);
      text-align: center;
      color: var(--color-text);
    }

    .btn-group {
      display: flex;
      flex-direction: column;
      gap: var(--space-16);
      width: 100%;
    }

    .btn {
      min-height: 48px;
      padding: var(--space-16) var(--space-24);
      font-size: var(--font-size-lg);
      font-weight: 500;
      border: none;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .btn-primary {
      background: var(--color-primary);
      color: var(--color-btn-primary-text);
    }

    .btn-primary:hover {
      background: var(--color-primary-hover);
    }

    .btn-primary:active {
      background: var(--color-primary-active);
      transform: scale(0.98);
    }

    .btn-secondary {
      background: var(--color-secondary);
      color: var(--color-text);
    }

    .btn-secondary:hover {
      background: var(--color-secondary-hover);
    }

    .btn-secondary:active {
      transform: scale(0.98);
    }

    .session-info {
      background: var(--color-surface);
      border: 1px solid var(--color-card-border);
      border-radius: var(--radius-lg);
      padding: var(--space-24);
      margin-bottom: var(--space-24);
      text-align: center;
    }

    .session-code {
      font-size: var(--font-size-2xl);
      font-weight: 600;
      letter-spacing: 0.2em;
      color: var(--color-primary);
      margin: var(--space-16) 0;
    }

    #qrcode {
      display: flex;
      justify-content: center;
      margin: var(--space-24) 0;
    }

    .input-group {
      margin-bottom: var(--space-24);
      width: 100%;
    }

    .input-label {
      display: block;
      font-size: var(--font-size-base);
      font-weight: 500;
      margin-bottom: var(--space-8);
      color: var(--color-text);
    }

    .input {
      width: 100%;
      min-height: 48px;
      padding: var(--space-12) var(--space-16);
      font-size: var(--font-size-lg);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-base);
      background: var(--color-surface);
      color: var(--color-text);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .input:focus {
      outline: 2px solid var(--color-primary);
      border-color: var(--color-primary);
    }

    /* Chat Screen */
    #chatScreen {
      padding: 0;
      height: 100vh;
      justify-content: flex-start;
    }

    #chatScreen.active {
      display: flex;
    }

    .chat-header {
      width: 100%;
      background: var(--color-surface);
      border-bottom: 1px solid var(--color-card-border);
      padding: var(--space-16) var(--space-20);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: var(--space-8);
      font-size: var(--font-size-base);
      font-weight: 500;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: pulse 2s ease-in-out infinite;
    }

    .status-connected .status-dot {
      background: var(--color-success);
    }

    .status-reconnecting .status-dot {
      background: var(--color-warning);
    }

    .status-disconnected .status-dot,
    .status-error .status-dot {
      background: var(--color-error);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .btn-disconnect {
      min-height: 36px;
      padding: var(--space-8) var(--space-16);
      font-size: var(--font-size-sm);
      background: var(--color-error);
      color: white;
    }

    .btn-disconnect:active {
      opacity: 0.8;
    }

    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: var(--space-20);
      display: flex;
      flex-direction: column;
      gap: var(--space-12);
      width: 100%;
    }

    .message {
      max-width: 80%;
      padding: var(--space-12) var(--space-16);
      border-radius: var(--radius-md);
      word-wrap: break-word;
      overflow-wrap: break-word;
      word-break: break-word;
      hyphens: auto;
    }

    .message-own {
      align-self: flex-end;
      background: var(--color-primary);
      color: var(--color-btn-primary-text);
      border-bottom-right-radius: var(--space-4);
    }

    .message-other {
      align-self: flex-start;
      background: var(--color-surface);
      border: 1px solid var(--color-card-border);
      color: var(--color-text);
      border-bottom-left-radius: var(--space-4);
    }

    .message-time {
      font-size: var(--font-size-sm);
      opacity: 0.7;
      margin-top: var(--space-4);
    }

    .reconnect-notice {
      text-align: center;
      padding: var(--space-12);
      background: rgba(var(--color-teal-500-rgb), 0.1);
      border: 1px solid var(--color-warning);
      border-radius: var(--radius-base);
      color: var(--color-warning);
      font-size: var(--font-size-sm);
      margin: var(--space-8) var(--space-20);
    }

    .input-bar {
      width: 100%;
      background: var(--color-surface);
      border-top: 1px solid var(--color-card-border);
      padding: var(--space-16) var(--space-20);
      display: flex;
      gap: var(--space-12);
      flex-shrink: 0;
    }

    .message-input {
      flex: 1;
      min-height: 44px;
      padding: var(--space-12) var(--space-16);
      font-size: var(--font-size-base);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-full);
      background: var(--color-background);
      color: var(--color-text);
    }

    .message-input:focus {
      outline: 2px solid var(--color-primary);
      border-color: var(--color-primary);
    }

    .btn-send {
      min-width: 48px;
      min-height: 48px;
      padding: var(--space-12);
      background: var(--color-primary);
      color: var(--color-btn-primary-text);
      border-radius: var(--radius-full);
      font-weight: 600;
    }

    .btn-send:active {
      transform: scale(0.95);
    }

    .error-message {
      background: rgba(var(--color-teal-500-rgb), 0.1);
      border: 1px solid var(--color-error);
      border-radius: var(--radius-base);
      padding: var(--space-16);
      margin-bottom: var(--space-16);
      color: var(--color-error);
      text-align: center;
    }

    .btn-retry {
      margin-top: var(--space-12);
      min-height: 44px;
      padding: var(--space-12) var(--space-20);
    }

    /* Mobile Optimizations */
    @media (max-width: 768px) {
      .screen {
        padding: var(--space-16);
      }

      h1 {
        font-size: var(--font-size-2xl);
        margin-bottom: var(--space-24);
      }

      .session-info {
        padding: var(--space-16);
      }

      #qrcode canvas {
        max-width: 150px !important;
        height: auto !important;
      }

      .messages-container {
        padding: var(--space-16);
      }

      .message {
        max-width: 85%;
        font-size: var(--font-size-base);
      }
    }

    /* Desktop optimizations */
    @media (min-width: 769px) {
      .container {
        max-width: 600px;
      }

      #chatScreen .messages-container {
        max-width: 800px;
        margin: 0 auto;
      }

      #qrcode canvas {
        max-width: 200px !important;
        height: auto !important;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Connection Screen -->
    <div id="connectionScreen" class="screen active">
      <div class="container">
        <h1>P2P Чат</h1>
        <div class="btn-group">
          <button id="createBtn" class="btn btn-primary">Создать новую сессию</button>
          <button id="joinBtn" class="btn btn-secondary">Присоединиться</button>
        </div>
      </div>
    </div>

    <!-- Create Session Screen -->
    <div id="createScreen" class="screen">
      <div class="container">
        <h1>Новая сессия</h1>
        <div class="session-info">
          <p>Код сессии:</p>
          <div class="session-code" id="sessionCode">------</div>
          <div id="qrcode"></div>
          <p style="color: var(--color-text-secondary); font-size: var(--font-size-sm);">Ожидание подключения...</p>
        </div>
        <button id="backFromCreate" class="btn btn-secondary">Назад</button>
      </div>
    </div>

    <!-- Join Session Screen -->
    <div id="joinScreen" class="screen">
      <div class="container">
        <h1>Присоединиться</h1>
        <div id="joinError" class="error-message" style="display: none;">
          <div id="joinErrorText"></div>
          <button id="retryBtn" class="btn btn-primary btn-retry" style="display: none;">Повторить попытку</button>
        </div>
        <div class="input-group">
          <label class="input-label" for="sessionCodeInput">Код сессии</label>
          <input type="text" id="sessionCodeInput" class="input" placeholder="Введите код" maxlength="6">
        </div>
        <div class="btn-group">
          <button id="connectBtn" class="btn btn-primary">Подключиться</button>
          <button id="backFromJoin" class="btn btn-secondary">Назад</button>
        </div>
      </div>
    </div>

    <!-- Chat Screen -->
    <div id="chatScreen" class="screen">
      <div class="chat-header">
        <div id="statusIndicator" class="status-indicator status-connected">
          <span class="status-dot"></span>
          <span id="statusText">Соединено</span>
        </div>
        <button id="disconnectBtn" class="btn btn-disconnect">Отключиться</button>
      </div>
      <div id="reconnectNotice" class="reconnect-notice" style="display: none;"></div>
      <div id="messagesContainer" class="messages-container"></div>
      <div class="input-bar">
        <input type="text" id="messageInput" class="message-input" placeholder="Введите сообщение...">
        <button id="sendBtn" class="btn btn-send">➤</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
  <script>
    // Global variables
    let peer = null;
    let connection = null;
    let myPeerId = null;
    let messages = [];
    let reconnectAttempts = 0;
    let connectionStatus = 'disconnected';
    let reconnectTimeout = null;
    let connectionTimeout = null;
    const MAX_RECONNECT_ATTEMPTS = 3;
    const CONNECTION_TIMEOUT = 30000;

    // DOM elements
    let elements = {};

    // Logging utility
    function log(message, data = null) {
      const timestamp = new Date().toISOString();
      if (data) {
        console.log(`[${timestamp}] ${message}`, data);
      } else {
        console.log(`[${timestamp}] ${message}`);
      }
    }

    // Generate 6-character session code
    function generateSessionCode() {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    }

    // Screen switching
    function showScreen(screenId) {
      log(`Switching to screen: ${screenId}`);
      document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('active');
      });
      const screen = document.getElementById(screenId);
      if (screen) {
        screen.classList.add('active');
      }
    }

    // Update status indicator
    function updateStatus(status, text) {
      connectionStatus = status;
      log(`Status updated: ${status} - ${text}`);
      
      const statusIndicator = elements.statusIndicator;
      const statusText = elements.statusText;
      
      if (!statusIndicator || !statusText) return;
      
      statusIndicator.className = 'status-indicator';
      statusIndicator.classList.add(`status-${status}`);
      statusText.textContent = text;
    }

    // Show reconnect notice
    function showReconnectNotice(text) {
      const notice = elements.reconnectNotice;
      if (notice) {
        notice.textContent = text;
        notice.style.display = 'block';
      }
    }

    function hideReconnectNotice() {
      const notice = elements.reconnectNotice;
      if (notice) {
        notice.style.display = 'none';
      }
    }

    // Error messages
    function getErrorMessage(errorType) {
      const errors = {
        'network': 'Ошибка сети. Проверьте подключение к интернету.',
        'peer-unavailable': 'Пользователь с таким кодом недоступен или не существует.',
        'unavailable-id': 'Этот код уже занят. Попробуйте создать новую сессию.',
        'invalid-id': 'Неверный формат кода сессии.',
        'webrtc': 'Ошибка WebRTC соединения. Попробуйте переподключиться.',
        'browser-incompatible': 'Ваш браузер не поддерживает WebRTC.',
        'disconnected': 'Соединение потеряно.',
        'server-error': 'Ошибка сервера. Попробуйте позже.',
        'timeout': 'Превышено время ожидания подключения.',
        'default': 'Произошла неизвестная ошибка. Попробуйте снова.'
      };
      return errors[errorType] || errors['default'];
    }

    // Show error in join screen
    function showJoinError(errorType) {
      log(`Showing join error: ${errorType}`);
      const errorDiv = elements.joinError;
      const errorText = elements.joinErrorText;
      const retryBtn = elements.retryBtn;
      
      if (errorDiv && errorText) {
        errorText.textContent = getErrorMessage(errorType);
        errorDiv.style.display = 'block';
        if (retryBtn) {
          retryBtn.style.display = 'block';
        }
      }
    }

    function hideJoinError() {
      const errorDiv = elements.joinError;
      if (errorDiv) {
        errorDiv.style.display = 'none';
      }
    }

    // Clean up resources
    function cleanup() {
      log('Cleaning up resources...');
      
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
        reconnectTimeout = null;
      }
      
      if (connectionTimeout) {
        clearTimeout(connectionTimeout);
        connectionTimeout = null;
      }
      
      if (connection) {
        try {
          connection.close();
        } catch (e) {
          log('Error closing connection:', e);
        }
        connection = null;
      }
      
      if (peer && !peer.destroyed) {
        try {
          peer.destroy();
        } catch (e) {
          log('Error destroying peer:', e);
        }
        peer = null;
      }
      
      reconnectAttempts = 0;
      messages = [];
    }

    // Setup connection event handlers
    function setupConnection(conn) {
      log('Setting up connection handlers');
      
      conn.on('open', () => {
        log('Connection opened');
        connection = conn;
        reconnectAttempts = 0;
        updateStatus('connected', '✓ Соединено');
        hideReconnectNotice();
        
        if (connectionTimeout) {
          clearTimeout(connectionTimeout);
          connectionTimeout = null;
        }
        
        showScreen('chatScreen');
      });
      
      conn.on('data', (data) => {
        log('Received message:', data);
        addMessage(data, false);
      });
    }

    // Reconnect with exponential backoff
    function attemptReconnect(targetPeerId) {
      if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
        log('Max reconnect attempts reached');
        updateStatus('error', '❌ Нет соединения');
        hideReconnectNotice();
        return;
      }
      
      reconnectAttempts++;
      const delay = reconnectAttempts * 2000; // 2, 4, 6 seconds
      
      log(`Reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);
      updateStatus('reconnecting', '⚠️ Переподключение...');
      showReconnectNotice(`Попытка переподключения (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
      
      reconnectTimeout = setTimeout(() => {
        if (!peer || peer.destroyed) {
          log('Peer destroyed, cannot reconnect');
          return;
        }
        
        try {
          connection = peer.connect(targetPeerId, {
            reliable: true
          });
          
          setupConnection(connection);
          
          connection.on('error', (err) => {
            log('Reconnection error:', err);
            attemptReconnect(targetPeerId);
          });
          
          connection.on('close', () => {
            log('Reconnection closed');
            if (connectionStatus === 'connected') {
              attemptReconnect(targetPeerId);
            }
          });
        } catch (error) {
          log('Error during reconnect:', error);
          attemptReconnect(targetPeerId);
        }
      }, delay);
    }

    // Create new session
    function createSession() {
      log('Creating new session...');
      cleanup();
      
      // Check for double creation
      if (peer && !peer.destroyed) {
        log('Peer already exists, returning');
        return;
      }
      
      myPeerId = generateSessionCode();
      log(`Generated peer ID: ${myPeerId}`);
      
      // Multiple STUN servers for better NAT traversal
      peer = new Peer(myPeerId, {
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun.services.mozilla.com' },
            { urls: 'stun:stun.stunprotocol.org:3478' }
          ]
        }
      });
      
      peer.on('open', (id) => {
        log(`Peer opened with ID: ${id}`);
        elements.sessionCode.textContent = id;
        
        // Generate QR code with proper colors
        const qrcodeDiv = elements.qrcode;
        qrcodeDiv.innerHTML = '';
        
        const bgColor = getComputedStyle(document.documentElement)
          .getPropertyValue('--color-charcoal-700').trim() || '#1f2121';
        const fgColor = getComputedStyle(document.documentElement)
          .getPropertyValue('--color-cream-100').trim() || '#fffffd';
        
        new QRCode(qrcodeDiv, {
          text: id,
          width: 200,
          height: 200,
          colorDark: bgColor,
          colorLight: fgColor
        });
        
        showScreen('createScreen');
      });
      
      peer.on('connection', (conn) => {
        log('Incoming connection received');
        setupConnection(conn);
        
        // Add event handlers outside setupConnection
        conn.on('close', () => {
          log('Connection closed by peer');
          if (connectionStatus === 'connected') {
            updateStatus('disconnected', '⚠️ Соединение потеряно');
            attemptReconnect(conn.peer);
          }
        });
        
        conn.on('error', (err) => {
          log('Connection error:', err);
          updateStatus('error', '❌ Ошибка соединения');
          attemptReconnect(conn.peer);
        });
      });
      
      peer.on('disconnected', () => {
        log('Peer disconnected from server');
        updateStatus('reconnecting', '⚠️ Переподключение к серверу...');
        
        if (!peer.destroyed) {
          setTimeout(() => {
            if (peer && !peer.destroyed) {
              log('Attempting to reconnect to signaling server');
              peer.reconnect();
            }
          }, 1000);
        }
      });
      
      peer.on('error', (err) => {
        log('Peer error:', err);
        let errorType = 'default';
        
        if (err.type === 'unavailable-id') {
          errorType = 'unavailable-id';
        } else if (err.type === 'network') {
          errorType = 'network';
        } else if (err.type === 'server-error') {
          errorType = 'server-error';
        } else if (err.type === 'browser-incompatible') {
          errorType = 'browser-incompatible';
        }
        
        alert(getErrorMessage(errorType));
        cleanup();
        showScreen('connectionScreen');
      });
    }

    // Join existing session
    function joinSession(sessionCode) {
      log(`Joining session: ${sessionCode}`);
      cleanup();
      hideJoinError();
      
      if (!sessionCode || sessionCode.length !== 6) {
        showJoinError('invalid-id');
        return;
      }
      
      // Check for double creation
      if (peer && !peer.destroyed) {
        log('Peer already exists, returning');
        return;
      }
      
      myPeerId = generateSessionCode();
      log(`Generated peer ID for joining: ${myPeerId}`);
      
      // Multiple STUN servers
      peer = new Peer(myPeerId, {
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun.services.mozilla.com' },
            { urls: 'stun:stun.stunprotocol.org:3478' }
          ]
        }
      });
      
      peer.on('open', (id) => {
        log(`Peer opened, connecting to: ${sessionCode}`);
        
        connection = peer.connect(sessionCode, {
          reliable: true
        });
        
        // Set connection timeout
        connectionTimeout = setTimeout(() => {
          log('Connection timeout');
          if (connectionStatus !== 'connected') {
            showJoinError('timeout');
            cleanup();
          }
        }, CONNECTION_TIMEOUT);
        
        setupConnection(connection);
        
        // Add event handlers outside setupConnection
        connection.on('close', () => {
          log('Connection closed');
          if (connectionStatus === 'connected') {
            updateStatus('disconnected', '⚠️ Соединение потеряно');
            attemptReconnect(sessionCode);
          }
        });
        
        connection.on('error', (err) => {
          log('Connection error during join:', err);
          
          let errorType = 'default';
          if (err.type === 'peer-unavailable') {
            errorType = 'peer-unavailable';
          } else if (err.type === 'network') {
            errorType = 'network';
          } else if (err.type === 'webrtc') {
            errorType = 'webrtc';
          }
          
          showJoinError(errorType);
          cleanup();
        });
      });
      
      peer.on('disconnected', () => {
        log('Peer disconnected from server during join');
        
        if (!peer.destroyed) {
          setTimeout(() => {
            if (peer && !peer.destroyed) {
              log('Attempting to reconnect to signaling server');
              peer.reconnect();
            }
          }, 1000);
        }
      });
      
      peer.on('error', (err) => {
        log('Peer error during join:', err);
        let errorType = 'default';
        
        if (err.type === 'unavailable-id') {
          errorType = 'unavailable-id';
        } else if (err.type === 'network') {
          errorType = 'network';
        } else if (err.type === 'server-error') {
          errorType = 'server-error';
        } else if (err.type === 'browser-incompatible') {
          errorType = 'browser-incompatible';
        }
        
        showJoinError(errorType);
        cleanup();
      });
    }

    // Add message to chat
    function addMessage(text, isOwn) {
      const time = new Date().toLocaleTimeString('ru-RU', { 
        hour: '2-digit', 
        minute: '2-digit' 
      });
      
      messages.push({ text, isOwn, time });
      renderMessages();
    }

    // Render all messages
    function renderMessages() {
      const container = elements.messagesContainer;
      if (!container) return;
      
      container.innerHTML = '';
      
      messages.forEach(msg => {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${msg.isOwn ? 'message-own' : 'message-other'}`;
        
        const textDiv = document.createElement('div');
        textDiv.textContent = msg.text;
        
        const timeDiv = document.createElement('div');
        timeDiv.className = 'message-time';
        timeDiv.textContent = msg.time;
        
        messageDiv.appendChild(textDiv);
        messageDiv.appendChild(timeDiv);
        container.appendChild(messageDiv);
      });
      
      // Scroll to bottom
      container.scrollTop = container.scrollHeight;
    }

    // Send message
    function sendMessage() {
      const input = elements.messageInput;
      if (!input) return;
      
      const text = input.value.trim();
      if (!text || !connection) return;
      
      log(`Sending message: ${text}`);
      connection.send(text);
      addMessage(text, true);
      input.value = '';
    }

    // Disconnect
    function disconnect() {
      log('User initiated disconnect');
      cleanup();
      showScreen('connectionScreen');
    }

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => {
      log('App initialized');
      
      // Cache DOM elements with validation
      elements = {
        createBtn: document.getElementById('createBtn'),
        joinBtn: document.getElementById('joinBtn'),
        backFromCreate: document.getElementById('backFromCreate'),
        backFromJoin: document.getElementById('backFromJoin'),
        sessionCode: document.getElementById('sessionCode'),
        qrcode: document.getElementById('qrcode'),
        sessionCodeInput: document.getElementById('sessionCodeInput'),
        connectBtn: document.getElementById('connectBtn'),
        retryBtn: document.getElementById('retryBtn'),
        joinError: document.getElementById('joinError'),
        joinErrorText: document.getElementById('joinErrorText'),
        statusIndicator: document.getElementById('statusIndicator'),
        statusText: document.getElementById('statusText'),
        reconnectNotice: document.getElementById('reconnectNotice'),
        messagesContainer: document.getElementById('messagesContainer'),
        messageInput: document.getElementById('messageInput'),
        sendBtn: document.getElementById('sendBtn'),
        disconnectBtn: document.getElementById('disconnectBtn')
      };
      
      // Validate elements exist before adding listeners
      if (elements.createBtn) {
        elements.createBtn.addEventListener('click', createSession);
      }
      
      if (elements.joinBtn) {
        elements.joinBtn.addEventListener('click', () => showScreen('joinScreen'));
      }
      
      if (elements.backFromCreate) {
        elements.backFromCreate.addEventListener('click', () => {
          cleanup();
          showScreen('connectionScreen');
        });
      }
      
      if (elements.backFromJoin) {
        elements.backFromJoin.addEventListener('click', () => {
          cleanup();
          showScreen('connectionScreen');
        });
      }
      
      if (elements.connectBtn) {
        elements.connectBtn.addEventListener('click', () => {
          const code = elements.sessionCodeInput?.value.trim().toUpperCase();
          if (code) {
            joinSession(code);
          }
        });
      }
      
      if (elements.retryBtn) {
        elements.retryBtn.addEventListener('click', () => {
          const code = elements.sessionCodeInput?.value.trim().toUpperCase();
          if (code) {
            joinSession(code);
          }
        });
      }
      
      if (elements.sessionCodeInput) {
        elements.sessionCodeInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            elements.connectBtn?.click();
          }
        });
      }
      
      if (elements.sendBtn) {
        elements.sendBtn.addEventListener('click', sendMessage);
      }
      
      if (elements.messageInput) {
        elements.messageInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
          }
        });
        
        // Auto-scroll to input on focus (mobile)
        elements.messageInput.addEventListener('focus', () => {
          setTimeout(() => {
            elements.messageInput?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }, 300);
        });
      }
      
      if (elements.disconnectBtn) {
        elements.disconnectBtn.addEventListener('click', disconnect);
      }
      
      log('Event listeners attached');
    });
  </script>
</body>
</html>